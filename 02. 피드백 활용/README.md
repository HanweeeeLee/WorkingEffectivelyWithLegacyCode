# 02. 피드백 활용
시스템을 변경하는 방법
 - 편집 후 기도하기(Edit and Pray)
 - 보호 후 수정하기(Cover and Modify)  

편집 후 기도하기가 업계 표준임 ㅎ.ㅎ  
  
### 편집 후 기도하기
1. 코드 변경 계획을 신중하게 세우고, 변경 대상 코드를 이해했는지 확인후 편집. 
2. 변경 완료 후에는 시스템을 실행해서 변경 사항이 제대로 동작하고 무언가 손상된 동작이 없는지 조사. 
3. 사이드 이팩트 있는지 확인(중요)
4. 변경 작업이 제대로 완료되길 희망하는 기도를 하고, 작업 결과를 확인하기 위해 추가로 시간을 들인다.

> 아무리 신중하게 주의를 기울여도 그에 비례해서 안정성이 높아진다는 보장은 없다.

### 보호 후 수정하기
 - 소프트웨어를 변경할 때 '안전망'을 이용하자
 - 테스트 루틴으로 코드를 덮자.
 - 변경 대상 코드의 주변에 배치된 테스트 루틴들은 소프트웨어 바이스의 역할을 할 수 있다. 소프트웨어 동작 대부분을 고정시키고, 변경하고자 하는 부분만 변경하고 확인 할 수 있다는 뜻.
```
소프트웨어 바이스

변경을 탐지하는 테스트 루틴을 사용하는 것은 곧 코드 주위에 바이스를 두는것과 같다.
코드의 동작은 그 상태로 고정된다. 따라서 한 번의 작업으로 한 개의 동작만 변경되고 있음을 확인할 수 있다.
즉, 자기 자신이 수행 중인 작업을 더 정밀하게 통제할 수 있음을 의미한다.
```
 - TDD로 개발하자.. (하다못해 단위 테스트를 추가하면서 개발하자)(맞나..?)

## 단위 테스트란?
기본 개념은 독립된 개별 소프트웨어 컴포넌트를 테스트하는 것. 절차적 프로그래밍에서는 함수, 객체지향은 클래스  
소프트웨어 오류는 소프트웨어의 각 조각들이 통합될 떄 발생한다. 대규모 테스트가 중요한거 아닐까?
### 대규모 테스트의 문제
 - 오류 위치 파악: 테스트 루틴이 테스트 대상으로부터 멀어지면 멀어질수록, 테스트 실패가 의미하는 바를 파악하기 힘들어진다. 그 결과, 테스트 실패가 발생한 위치 를 파악하는데 리소스가 많이 든다. 하지만 테스트의 규모가 작아지면 어려운 일이 아니다.
 - 실행 시간: 시간이 오래걸린다.. 결국 테스트를 안하게 됨
 - 커버리지: 새로운 기능이 추가 될 경우 그 코드를 실행하기 위한 상위 단계 테스트 루틴을 작업하기 위해 매우 많은 코드 작성량이 필요해진다.
->
**함수나 클래스의 분리 테스트는 단위 테스트의 의미상 매우 중요하다.**
  
### 좋은 단위 테스트의 조건
 - 실행 속도가 빠르다.
 - 오류 위치 파악에 도움이 된다.

##### 다음과 같은 테스트는 단위 테스트가 아니다.
 1. 데이터베이스와 연동한다.
 2. 네트워크를 통해 통신한다.
 3. 파일시스템을 건드린다.
 4. 테스트 실행을 위해 (설정 파일 편집과 같이) 특별한 작업을 해야 한다.

## 상위 수준의 테스트
애플리케이션 내의 시나리오나 상호작용을 테스트하는 상위 수준의 테스트가 필요할 때가 있다.  
상위 수준의 테스트가 완료되면 개별 클래스에 대한 테스트 루틴 작성도 쉬워질 때가 많다.

## 테스트를 통한 코드 보호
레거시 프로젝트에서 변경 작업을 할 때 어떤 일부터 시작해야 할까?  
변경을 가할 코드 주위에 테스트 루틴을 배치해야 한다. 코드를 변경할 때는 오류가 생기기 마련이다. 결국 사람이 하는 일이기 때문  
변경을 가하기 전에 테스트 루틴으로 코드를 보호한다면, 발생한 오류를 좀 더 쉽게 잡아낼 수 있다.  

<img width="578" alt="스크린샷 2022-11-14 오후 11 07 43" src="https://user-images.githubusercontent.com/60125719/201680684-1905c02a-9e51-4878-bb90-1ec5be5e6333.png">

> InvoiceUpdateResponder 클래스의 getResponseText 메소드와 Invoice클래스의 getValue 메소드를 변경하고 싶다고하자. 이 두개의 메소드가 바로 변경 지점인 것. 이 메소드들을 포함하는 클래스에 테스트루틴을 작성함으로써 이 메소드들을 보호할 수 있다.
  
> 테스트를 하기위해서는 각각의 클래스들의 객체를 생성해야함. Invoice는 문제 없음. 그런데 InvoiceUpdateResponder는 생성자에 DB를 넣어야한다. 그렇다면 테스트에 DB를 넣어야할까? 당연히 아님. 사실 더 큰 문제는 InvocieUpdateServlet 인스턴스를 받아야하는데 이 서블릿 객체를 만드는것도 매우 어려움

  
결국 이러한 문제들은 모두 의존 관계와 관련돼 있다. 테스트하기 어려운 무언가에 직접 의존하는 클래스는 다루거나 수정하기 어렵다.  
여기서는 DB지만 GUI와 연동되어 있을 수도 있고 기타등등..  
```
레거시 코드의 딜레마
코드 변경을 하려면 테스트 코드를 배치해야 한다. 그런데 테스트 코드를 배치하려면 코드 변경이 필요할 때가 많다.
```

<img width="529" alt="스크린샷 2022-11-14 오후 11 15 04" src="https://user-images.githubusercontent.com/60125719/201682300-06aaa4ae-4212-4c80-acf2-de4214670e9e.png">

> 이런 식으로 의존성을 끊어야 한다. 기본 타입 매개변수, 인터페이스 추출. 매우 보수적으로 리팩토링을 수행해야 한다.
  
```
레거시 코드에서 의존 관계를 제거할 때는 미적인 감각을 다소 내려놓아야한다.
깨끗하게 제거 되는 의존도 있지만 그렇지 않을때도 많음
하지만 그 코드들은 안전하게 동작할 것이다.
의존 관계를 제거한 지점 주위에 코드를 보호하는 테스트를 작성함으로써 더 멋지게 작업할 수 있다.
```

## 레거시 코드를 변경하는 순서
1. 변경 지점을 식별한다.
2. 테스트 루틴을 작성할 위치를 찾는다.
3. 의존 관계를 제거한다.
4. 테스트 루틴을 작성한다.
5. 변경 및 리팩토링을 수행한다.

우리는 매일 리팩토링하지만 아무 변경이나 다 좋은것은 아니고 좀 더 가치있는 방향으로 기능을 개선함과 동시에 테스트로 보호받는 시스템 내의 코드 영역을 확대하는 것이 중요하다.  
프로그래밍이 끝날 때마다 새로운 기능의 추가뿐 아니라 테스트 루틴의 추가도 함께 확인해야 한다.  

### 변경 지점을 식별한다
코드 변경을 수행할 지점은 소프트웨어 아키텍처와 밀접히 연관돼 있다.

### 테스트 루틴을 작성할 위치를 찾는다
테스트 루틴을 작성할 곳을 찾기 쉬울 때도 있지만, 레거시 코드의 경우 찾기 어려운 것이 일반적이다.

### 의존 관계를 제거한다
테스트를 실행할 때 의존 관계는 분명히 가장 큰 장애물이다.  
의존 관계가 문제가 되는 가장 대표적인 두가지: 1.테스트 하네스 내부에서의 객체 인스턴스 생성과 2.메소드 실행  

### 테스트 루틴을 작성한다
레거시 코드에서 작성하는 테스트 루틴은 신규 코드에 대한 테스트 루틴과는 다른점이 있다. (13장에서 할 예정)

### 변경 및 리팩토링을 수행한다
TDD를 사용하자.  





































# 04. 봉합 모델
## 봉합
단위 테스트를 위해 개별 클래스를 추출하려고 하면 대부분 수많은 의존 관계를 제거할 필요가 있다.  
아무리 '좋은' 설계를 기반하고 있다 하더라도 많은 작업이 수반된다.  
```
봉합

봉합 지점은 코드를 직접 편집하지 않고도 프로그램의 동작을 변경할 수 있는 위치를 말한다.
```

그런데 왜 봉합을 사용해야 할까? 봉합의 개념은 어떤 쓸모가 있는 것일까?  
레거시 코드를 테스트할 때 가장 큰 문제점은 의존 관계를 제거하는 일이다.  
운이 좋은 경우 의존관계가 몇개밖에 안되고 지역화되어 있지만, 어떤 경우에는 의존관계가 수없이 많이 코드 전체에 두루 퍼져있을 수 있다.  
소프트웨어를 봉합 관점에서 바라보면, 코드에 포함되어 있는 의존 관계를 제거하기 위한 단서들을 엿볼 수 있다.
테스트할 때 봉합 지점에서 동작을 다른 것으로 변경할 수 있다면 의존 관계를 일부분 제거할 수 있기 때문이다.  
이와 같은 의존 관계가 존재하는 위치에서 별도의 코드를 실행시킴으로서, 코드 전체의 조건문에 대해 테스트 루틴을 작성할 수도 있게 된다.  
이러한 작업을 통해 충분한 테스트를 준비할 수 있고, 좀 더 적극적인 테스트를 수행할 수 있다.

## 봉합의 종류
사용할 수 있는 봉합의 종류는 프로그래밍 언어마다 차이가 있다.

### 전처리 봉합
대부분의 프로그래밍 환경에서 프로그램 소스 코드는 컴파일러에 입력된다. 그렇다면 컴파일 이전의 단계에서는 어떤 작업이 수행될까?  
컴파일 이전에 빌드의 한 단계를 수행하는 언어는 그다지 많지 않다. 그중에서 대표적인 것이 C와 C++이다.  
C와 C++에서는 컴파일 이전에 매크로 전처리기가 실행되고, 이는 봉합 지점을 제공해 준다.  
C언어 전처리기의 #include 지시어는 컴파일 전에 텍스트를 대체할 수 있는 봉합인 전처리 봉합을 제공해주고 이는 테스트 장애 요소들을 효과적으로 해결할 수 있게 해준다.  
전처리 봉합 뿐만 아니라 모든 봉합에는 활성화 지점이 존재하는데, 봉합이 있다는것은 동작을 변경할 수 있는 위치가 있다는 의미이다.
```
활성화 지점

모든 봉합은 활성화 지점을 갖는다.
활성화 지점에서는 어느동작을 사용할지 선택할수 있다.
```

### 링크 봉합
많은 프로그래밍 언어에서는 컴파일만으로 빌드가 완료되지 않는다.  
컴파일러는 코드의 중간 표현을 생성하고, 이 중간표현은 다른 파일에 들어있는 코드를 호출한다.  
이때 링커(linker)는 이러한 중간 표현들을 조합하는데, 링커가 호출주소를 변환해주기 떄문에 완전한 실행 프로그램을 만들수 있다.

C나 C++의 경우는 링커가 별도로 존재하지만 자바에서는 이러한 작업을 컴파일러가 내부적으로 수행하며 언어별로 주소 변환을 수행하는 방법은 다르지만, 일반적으로 링크 봉합 기법을 사용해 프로그램의 일부를 대체 할 수 있다.  
이러한 언어별 특성을 사용해서 테스트시 의존성에서 쉽게 빠져나갈 수 있는 방법으로 매우 유용하다.  

C나 C++의 경우 일반적으로 링크 봉합을 이용하는 가장 쉬운 방법은, 대체 대상인 클래스나 함수에 대해 별도의 라이브러리를 작성한 후 테스트용으로 빌드 스크립트를 변경해서 원래의 라이브러리에 링크 시키는 것이다.  

링크 봉합의 활성화 지점은 언제나 소스코드의 외부에 위치한다.  
빌드 스크립트나 배치 스크립트 내부에 위치 할 때도 있기 때문에 링크 봉합을 사용하고 있음을 알아차리기 어려운 경우가 있다.
```
링크 봉합을 사용할 때는 테스트 환경과 제품(배포)환경 간에 분명한 차이가 있도록 구성해야 한다.
```


### 객체 봉합
객체 봉합은 객체 지향 언어에서 사용할 수 있는 봉합 기법들 중에서 가장 유용하다.  
다음의 예제를 보자
![KakaoTalk_20221201_190118477](https://user-images.githubusercontent.com/50142323/205024099-0a709286-3206-4921-906a-7443356b0940.jpg)
다음과 같이 호출했을 때 어느 메소드가 호출될까?
```JAVA
cell.Recalculate();
```
cell 변수가 어느 객체를 가리키는지 모르면 어느 함수가 호출될지 알 수 없다.  
다른 코드의 변경없이 호출되는 REcalculate 메소드를 변경할 수 있다면 이 호출 위치를 봉합지점이라고 부를 수 있다.  
다만, 객체 지향 언어의 메소드 호출이 언제나 봉합 지점이 되는것은 아니다.  
다음 예제는 봉합이 아닌 호출을 보여준다.
```JAVA
public class CustomSpreadsheet extends Spreadsheet
{
  public Spreadsheet buildMartSheet() {
    ...
    Cell cell = new FormulaCell(this, "A1", "=A2+A3");
    ...
    cell.Recalculate();
    ...
  }
  ...
}
```
이 코드에서는 셀을 생성하고 동일 메소드 내에서 이 객체를 사용하고 있다.  
이 경우 Recalculate 메소드 호출은 객체 봉합이 아니다. 활성화 지점이 없기 떄문이다.  
선택권은 cell 변수에 저장된 객체의 클래스에게 있으며, 우리는 호출될 Recalculate 메소드를 변경할 수 없다.  
Cell 변수의 클래스는 객체가 생성될 때 결정되므로, 메소드를 수정하지 않으면서 cell 클래스를 변경할 수는 없다.
다음의 경우를 보자
```JAVA
public class CustomSpreadsheet extends Spreadsheet
{
  public Spreadsheet buildMartSheet(Cell cell) {
    ...
    cell.Recalculate();
    ...
  }
  ...
}
```
cell.Recalculat 호출은 봉합 지점일까? 그렇다.  
테스트중에 CustomSpreadsheet 클래스를 작성한 후, 어떤 종류의 Cell 객체든 인수로서 제공하면서 buildMartSheet 메소드를 호출할 수 있기 때문이다.  
따라서 호출하는 쪽의 코드를 변경하지 않으면서 cell.Recalculate 메소드의 동작을 변경할 수 있다.  
여기서 활성화 지점은 buildMartSheet의 인수 리스트다.  
어떤 종류의 객체를 전달할지 결정하고, 테스트에 필요하도록 Recalculate 메소드의 동작을 변경 할 수 있기 때문이다.

### 결론
테스트를 수행 할 때 적절한 종류의 봉합을 선택하는 것은 중요한 일이다.  
일반적으로 객체 봉합은 객체 지향 언어에서 가장 적합한 방법이다.  
전처리 봉합과 링크 봉합도 편리할 때가 있지만 객체 봉합만큼 분명하지는 않을뿐더러, 전처리 봉합과 링크 봉합에 의존하는 테스트 루틴은 관리하기도 매우 어렵다.  
전처리 봉합과 링크 봉합은 의존관계가 매우 복잡하거나 다른 대안이 없을 경우에 최후의 카드로서 사용하는 편이 바람직하다.

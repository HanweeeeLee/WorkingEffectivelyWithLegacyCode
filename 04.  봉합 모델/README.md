# 04. 봉합 모델
## 봉합
단위 테스트를 위해 개별 클래스를 추출하려고 하면 대부분 수많은 의존 관계를 제거할 필요가 있다.  
아무리 '좋은' 설계를 기반하고 있다 하더라도 많은 작업이 수반된다.  
```
봉합

봉합 지점은 코드를 직접 편집하지 않고도 프로그램의 동작을 변경할 수 있는 위치를 말한다.
```

그런데 왜 봉합을 사용해야 할까? 봉합의 개념은 어떤 쓸모가 있는 것일까?  
레거시 코드를 테스트할 때 가장 큰 문제점은 의존 관계를 제거하는 일이다.  
운이 좋은 경우 의존관계가 몇개밖에 안되고 지역화되어 있지만, 어떤 경우에는 의존관계가 수없이 많이 코드 전체에 두루 퍼져있을 수 있다.  
소프트웨어를 봉합 관점에서 바라보면, 코드에 포함되어 있는 의존 관계를 제거하기 위한 단서들을 엿볼 수 있다.
테스트할 때 봉합 지점에서 동작을 다른 것으로 변경할 수 있다면 의존 관계를 일부분 제거할 수 있기 때문이다.  
이와 같은 의존 관계가 존재하는 위치에서 별도의 코드를 실행시킴으로서, 코드 전체의 조건문에 대해 테스트 루틴을 작성할 수도 있게 된다.  
이러한 작업을 통해 충분한 테스트를 준비할 수 있고, 좀 더 적극적인 테스트를 수행할 수 있다.

## 봉합의 종류
사용할 수 있는 봉합의 종류는 프로그래밍 언어마다 차이가 있다.

### 전처리 봉합
대부분의 프로그래밍 환경에서 프로그램 소스 코드는 컴파일러에 입력된다. 그렇다면 컴파일 이전의 단계에서는 어떤 작업이 수행될까?  
컴파일 이전에 빌드의 한 단계를 수행하는 언어는 그다지 많지 않다. 그중에서 대표적인 것이 C와 C++이다.  
C와 C++에서는 컴파일 이전에 매크로 전처리기가 실행되고, 이는 봉합 지점을 제공해 준다.  
C언어 전처리기의 #include 지시어는 컴파일 전에 텍스트를 대체할 수 있는 봉합인 전처리 봉합을 제공해주고 이는 테스트 장애 요소들을 효과적으로 해결할 수 있게 해준다.  
전처리 봉합 뿐만 아니라 모든 봉합에는 활성화 지점이 존재하는데, 봉합이 있다는것은 동작을 변경할 수 있는 위치가 있다는 의미이다.
```
활성화 지점

모든 봉합은 활성화 지점을 갖는다.
활성화 지점에서는 어느동작을 사용할지 선택할수 있다.
```

### 링크 봉합
많은 프로그래밍 언어에서는 컴파일만으로 빌드가 완료되지 않는다.  
컴파일러는 코드의 중간 표현을 생성하고, 이 중간표현은 다른 파일에 들어있는 코드를 호출한다.  
이때 링커(linker)는 이러한 중간 표현들을 조합하는데, 링커가 호출주소를 변환해주기 떄문에 완전한 실행 프로그램을 만들수 있다.

C나 C++의 경우는 링커가 별도로 존재하지만 자바에서는 이러한 작업을 컴파일러가 내부적으로 수행하며 언어별로 주소 변환을 수행하는 방법은 다르지만, 일반적으로 링크 봉합 기법을 사용해 프로그램의 일부를 대체 할 수 있다.  
이러한 언어별 특성을 사용해서 테스트시 의존성에서 쉽게 빠져나갈 수 있는 방법으로 매우 유용하다.  

C나 C++의 경우 일반적으로 링크 봉합을 이용하는 가장 쉬운 방법은, 대체 대상인 클래스나 함수에 대해 별도의 라이브러리를 작성한 후 테스트용으로 빌드 스크립트를 변경해서 원래의 라이브러리에 링크 시키는 것이다.  

링크 봉합의 활성화 지점은 언제나 소스코드의 외부에 위치한다.  
빌드 스크립트나 배치 스크립트 내부에 위치 할 때도 있기 때문에 링크 봉합을 사용하고 있음을 알아차리기 어려운 경우가 있다.
```
링크 봉합을 사용할 때는 테스트 환경과 제품(배포)환경 간에 분명한 차이가 있도록 구성해야 한다.
```


### 객체 봉합

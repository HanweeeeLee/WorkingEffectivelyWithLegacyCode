# 20. 이 클래스는 너무 비대해서 더이상 확장하고 싶지 않다
시스템에 추가되는 신규 기능은 대체로 약간의 코드와 몇개의 메소드만 추가하면 되는데 이러면 기존 클래스를 직접 변경하기 쉽다.  
추가하려는 코드가 기존 클래스의 데이터를 사용하는 경우 가장 손쉬운 방법은 기존 클래스에 코드를 추가하는 것이기 때문이다.  
하지만 이런 안이한 방법은 심각한 문제를 발생시킬수 있는데, 기존 클래스에 코드를 계속 추가하다 보면,  
결국은 대규모 메소드를 갖는 거대한 클래스가 되버린다.  
이후 신규 기능 추가는 물론이고 기존 기능을 이해하는데에도 많은 시간이 들게 된다.  
클래스가 커지면 어떠한 문제가 있는가?  
첫번째론 너무나 많은 메소드나 인스턴스 변수 등으로 인해 어디에 어떤 영향이 미치는지 파악하기 혼란스러워 진다.  
두번째로는 작업계획의 조정이다. 한개의 클래스가 10개 20개의 책임을 가지고 있으면 그 클래스를 변경해야 하는 이유도 매우 많아지고 작업 주기 동안 다수의 프로그래머들이 해당 클래스에 서로 다른 이유로 동시에 변경을 시도하게 되고, 그 작업들이 동시에 수행되면 심각하게 혼란해진다.  
그리고 세번째로 크기가 거대한 클래스는 테스트 작성이 어렵다는 문제가 더해지면 더욱 심각해지게 된다.  
거대한 클래스를 개선하는 핵심은 *리펙토링* 이다. 리팩토링은 클래스를 작은 클래스들로 쪼개는데 도움을 준다.  
문제는 어떤 작은 클래스로 되는지 파악하는 것이다. 이 장에서는 참고할 만한 몇가지 지침을 알아보자.  

> **단일책임원칙**  
> 모든 클래스는 단일한 책임을 가져야한다. 클래스는 시스템 내에서 한개의 목적만을 가져야하고, 클래스를 변경하는 이유도 한개여야 한다.

단일책임원칙을 매우 단순하게 생각하면 "모든 클래스가 오직 한개의 메소드만 가져야 한다." 라고 말하기 쉽다.  
확실히 메소드가 곧 책임이라고 생각 할수도 있지만 책임의 실제 의미는 클래스의 '주요 목적'을 논의할때 명확히 드러난다.
![KakaoTalk_20230313_144126310](https://user-images.githubusercontent.com/50142323/224618442-9d0dd5e7-81e2-4715-9ee3-81c6b3eeaec2.jpg)
이 그림을 보면 이 클래스는 어떤 언어의 규칙 표현식을 포함하는 문자열을 평가한다. 이 클래스는 어떤 책임들을 가지고 있을까?  
RuleParser 클래스 이므로 파싱 책임을 가질것이다.  
그런데 파싱이 이 클래스의 주요 목적일까? 파싱뿐 아니라 평가도 하기 때문에 파싱이 주요목적이라고 말할 수 없는 것 같다.  
그 밖으론 이 클래스는 current 변수에 현재 파싱중인 문자열을 저장한다.  
파싱중인 문자열의 현재 위치를 저장하는 currentPosition 변수도 갖고 있는데 이 두개의 책임은 파싱에 포함시켜도 좋을것 같다.  
  
또 다른 변수인 variables를 살펴보면 이 변수는 a+3와 같은 산술식을 계산하기 위해 파싱중에 사용되는 변수와 그 값의 쌍을 저장한다.  
addVariable 메소드를 호출할 경우, a+3 식을 평가하면 그 결과는 4가 된다. 따라서 이 클래스는 '변수 관리' 라는 책임도 갖고 있는것 같다.  
  
이것들 말고도 책임이 있을까? 책임을 찾는 또다른 방법은 메소드 이름을 살펴보는 것이다.  
이름에 동일 단어가 포함된 메소드끼리 묶으면 다음과 같이 분류할 수 있다.
![KakaoTalk_20230313_150308714](https://user-images.githubusercontent.com/50142323/224620236-67302c35-7ecc-4ce9-88fd-afd9cbb59c11.jpg)
evaluate 메소드는 이 클래스의 진입지점(endpoint) 이며 클래스의 주요 책임인 '평가'를 수행한다. 이름이 Expression으로 끝나는 네게의 메소드들은 Node 객체를 매개변수를 입력받고 하위식의 값을 나타내는 정수형 값을 반환하는 점이 동일하다.  
Term 의 이름을 갖는 메소드들은 토큰화와 관련있는 것처럼 보인다. 그리고 addVariable 메소드는 변수 관리와 관련 있다.  
지금까지의 내용을 정리하면 다음과 같은 책임들을 가진다
 - 파싱
 - 표현식 평가
 - 토큰화
 - 변수 관리

이런 책임들을 모두 별도로 나눠서 클래스를 설계했다면 다음과 같은 구조가 됐을 것이다.  
![KakaoTalk_20230313_151459898](https://user-images.githubusercontent.com/50142323/224621944-460694f7-94a3-4c37-8b62-3b199f02a7bb.jpg)
이 설계는 지나치게 세분화 된것 일수도 있고, 상당부분이 가설에 기초하고 있다.  
실제로 거대한 클래스를 다룰때 중요한 것은, 서로 다른 책임들을 식별한 후 적절한 위치로 옮기는 방법을 찾는 것이다.

## 책임파악
좀전의 예제는 클래스를 작은 클래스로 나누는 방법을 보여줬다.  
먼저 모든 메소드들을 나열한 후 그 이름을 통해 메소드의 목적이 무엇인지 유추한 후 비슷한 이유를 갖는 메소드들을 그룹화 했다.  
이런 책임파악 기법을 *메소드 그룹화* 라고 부른다.  
책임을 찾을수 있는 능력은 중요한 설계 스킬로서 충분한 연습이 요구된다. 중요한 점은 책임 파악 및 그 책임의 적절한 분리 방법을 배워야 한다는 것이다.  
다음은 기존 코드의 책임을 찾아내는데 사용할 수 있는 경험칙들을 설명한다.

> **경험칙 #1 : 메소드들을 분류한다.**  
> 이름이 비슷한 메소드들을 찾는다. 클래스의 모든 메소드들을 접근속성(public, private 등)과 함께 적어보고, 묶을 만한 메소드들이 있는지 찾아보자.
이 메소드 그룹화는 책임 파악을 시작할때 적용하기 좋은 기법이며, 특히 거대한 클래스에 적합하다.

> **경험칙 #2 : 숨겨진 메소드들을 조사한다.**  
> private 메소드들과 protected 메소드들에 주의한다. 클래스 내에 private 혹은 protected 메소드들이 많다면, 별도의 클래스를 추출해야 함을 시사한다.

> **경험칙 #3 : 변경 가능한 결정 사항을 찾아라**  
> 결정 사항을 찾는다. 코드에 지금부터 작성할 결정 사항이 아니라 이미 결정이 끝난 사항을 의미한다.  
> 데이터 베이스 연결이나 다른 객체와의 통신 등 무언가를 수행하기 위한 방법으로서 하드코딩된 것이 있을까? 그리고 그것이 변경될 것이라고 생각할 수 있을까?
거대한 클래스를 분할할 때 자칫 메소드 이름에만 주의를 기울이게 되기 쉽다.  
하지만 메소드 이름은 클래스에서 가장 눈에 띄는 것의 하나일 뿐이며, 메소드 이름만으론 모든걸 알수는 없다.  
그러하기에 클래스 추출을 결정하기 전에 메소드 추출 리팩토링을 조금 해두는 것이 효과적인데 어떤 메소드를 추출해야 할까?  
이에 대한 답을 찾기 위해 결정 사항을 찾는다.

> **경험칙 #4 : 내부 관계들을 찾아낸다**  
> 인스턴스 변수와 메소드 사이의 관계를 찾는다. 어떤 인스턴스 변수가 일부의 메소드에서만 사용되고 있지는 않은가?
클래스 내의 모든 메소드들이 모든 인스턴스 변수들을 사용하는 경우는 매우 드물다.  
일반적으로 클래스 안에는 이른바 '덩어리' 라고 부르는 것들이 존재한다. 세개의 변수가 있을때 이 변수들을 모두 사용하는 메소드는 겨우 2~3개 뿐일지도 모른다.  
이때도 메소드 이름이 도움을 주기도 한다. 예를들면 이전의 RulerParser 클래스에는 variables라는 이름의 컬렉션 변수와 addVariable 이라는 이름의 메소드가 있는데,  
이름을 통해 우리는 둘 사이에 명백한 관계가 있음을 알수 있다. 이를 통해 최소한 우리가 어디부터 살펴봐야 할지 알려준다.  

> **경험칙 #5 : 주요 책임을 찾는다**  
> 클래스의 책임을 한 개의 문장으로 기술하도록 노력한다.
단일 책임 원칙에 의하면 클래스는 한 개의 책임만을 가져야 한다. 따라서 클래스가 단일 책임 원칙에 부합한다면 한개의 문장으로 책임을 간단히 작성할 수 있어야 한다.  
시스템 내의 거대한 클래스를 대상으로 문장 작성을 시도해 보면, 클래스는 이런 일도 하고 저런 일도 하게 될것이다.  
그중에서 다른것 보다 중요해 보이는 것이 존재한다면, 그것이 클래스의 주요 책임이다. 나머지 책임들은 다른 클래스로 옮겨도 아마 무방할 것이다.  
단일 책임 원칙의 위반은 크게 두가지로 나뉘는데
 - 인터페이스 수준의 위반
 - 구현 수준의 위반
이 중 인터페이스 수준에서의 위반은 한개의 클래스가 너무 많은 것에 대해 책임을 갖는 인터페이스를 가지는 경우이고,  
가장 조심해야 하는것은 구현 수준에서의 위반이다. 클래스가 모든 책임을 실제 수행하는지, 아니면 다른 클래스에 위임할 뿐인지 살펴봐야 한다.

> **경험칙 #6 : 다른 모든 방법이 실패한 경우, 스크래치 리팩토링을 수행한다**  
> 클래스 내의 책임을 찾기가 매우 어렵다면 스크래치 리팩토링을 시도한다.

> **경험칙 #7 : 현재 작업에 집중한다**  
> 지금 당장 처리해야 하는 작업에 주의를 기울인다.  
> 어떤 작업을 수행할 수 있는 별도의 구현 방법이 발견됐다면, 추출되고 대체돼야 할 별도의 책임을 식별한 것일지도 모른다.

## 그밖의 기법들
책임을 식별하기 위한 경험칙들은 기존 클래스를 조사해 새로운 추상적 개념을 발견하는데 도움이 되지만, 단순한 임기응변에 지나지 않는다.  
책임 식별을 정말로 잘하려면 다양한 문서를 많이 읽어보는 것이다. 책이나 다른사람의 코드를 어떻게 작성했는지, 클래스들이 어떻게 명명되었고 클래스 이름과 메소드의 이름간의 관련성에 주목하자.

## 더 나아가기
### 전략
각각의 책임을 식별하고 나면 다음에는 어떤 일을 해야 할까?  
저자는 개발팀이 대규모의 리팩토링에 과감하게 도전할 때 아무리 작업을 신중하게 진행하고 테스트 루틴을 작성해도 얼마동안은 시스템의 안정성이 떨어졌다고 한다.  
출시 주기의 초반이고 위험을 감수하고 시간또한 충분하다면 대규모 리팩토링도 나쁘지 않다.  
거대한 클래스를 나누는 가장 좋은 접근법은 책임을 식별하고 팀원들에게 책임을 이해시킨후 필요에 따라 클래스를 분할하는 것이다.  
변경으로 인한 위험을 분산시키고 동시에 다른 작업도 수행할 수 있다.

### 전술
어떤 클래스 추출기법을 사용할지 결정할때는 다양한 요인을 고려해야 하는데, 그중 하나는 영향을 받는 메소드에 대한 테스트 루틴을 얼마나 쉽게 작성할 수 있느냐다.  
클래스를 조사한 후, 이동해야 할 인스턴스 변수와 메소드를 전부 나열하는 것이 좋다.  
이 과정에서 어떤 메소드에 대해 테스트 루틴을 작성할 것인지에 대한 아이디어를 얻을 수 있다.  
적절한 자리에 테스트 루틴을 배치했다면, 마틴 파울러의 책 **refactoring** 에 실려있는 클래스 추출 기법을 사용해 쉽게 클래스 추출을 시작할 수 있다.  
이 방법은 조금 위험할 수도 있지만 테스트 루틴이 존재하지 않는 상황에서도 앞으로 나아갈 수 있다.  
  
1. 별도 클래스로 분리하려는 책임을 식별한다.
2. 새로운 클래스로 이동시켜야 할 인스턴스 변수가 있는지 확인한다. 이동시킬 인스턴스 변수가 확인되면, 다른 인스턴스 변수들과 분리시킨 후 클래스 선언내의 구분된 영역으로 이동시킨다.
3. 새로운 클래스로 전체를 이동시킬 메소드가 있다면, 각 메소드의 본문을 새로운 메소드로서 추출한다. 새로운 메소드의 이름은 기존 메소드와 동일하되, MOVING 등과 같이 대문자로 이뤄진  공통 접두어를 붙인다. 메소드를 추출한 후, 클래스 선언부의 구분된 영역에 둔다.
4. 메소드의 일부분을 다른 클래스로 이동시키고 싶다면, 기존 메소드에서 그 부분을 추출하고 이번에도 역시 MOVING 접두어를 사용해서 메소드 이름을 짓고 클래스 선언의 구분된 영역에 둔다.
5. 이제 이동시킬 메소드와 인스턴스 변수들이 클래스 선언의 구분된 영역에 모여 있다. 대상 클래스와 그 서브클래스에 대해 문자열 검색을 수행해 이동시킬 변수가 이동시킬 메소드 외부에서는 사용되지 않음을 확인하는데 이때 컴파일러에게 맡기지 않는것이 중요하다. 다른 변수를 은닉하고 있는 변수가 사용되는 위치에 대해서는 컴파일러 맡기기 기법으로 발견할 수 없다.
6. 이제 구분 영역에 모여있는 인스턴스 변수와 메소드를 새로운 클래스로 직접 이동시킬 수 있다. 기존 클래스에서 신규 클래스의 인스턴스를 생성한 후, 컴파일러에게 맡기기 기법을 사용해 기존 클래스 대신에 신규 클래스 인스턴스를 호출해야 하는 위치를 발견한다.
7. 모두 이동시키고 컴파일이 완료되면, 이동된 메소드의 이름에서 MOVING 접두어를 삭제해도 된다. 이름 변경이 필요한 위치를 찾기 위해 컴파일러에게 맡기기 기법을 사용하자.

과정이 상당히 복잡하지만, 코드가 매우 복잡하고 테스트 루틴이 존재하지 않는 상황에서 안전하게 클래스를 추출하려면 이러한 과정을 거쳐야만 한다.  


## 클래스 추출을 마친 후
거대 클래스로부터 클래스들을 추출하는 일은 좋은 첫걸음이 될 수 있다.  
개선을 위해서는 이미 존재하고있는 것들을 충분히 고려하고, 반드시 이상적인 설계는 아닐지라도 최소한 지금보다 나은 방향을 바라봐야 한다.

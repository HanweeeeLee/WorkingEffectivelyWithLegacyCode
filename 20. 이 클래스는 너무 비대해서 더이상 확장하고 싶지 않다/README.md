# 20. 이 클래스는 너무 비대해서 더이상 확장하고 싶지 않다
시스템에 추가되는 신규 기능은 대체로 약간의 코드와 몇개의 메소드만 추가하면 된다. 이때 기존 클래스를 직접 변경하기 쉽다.  
추가하려는 코드가 기존 클래스의 데이터를 사용하는 경우 가장 손쉬운 방법은 기존 클래스에 코드를 추가하는 것이기 때문이다.  
하지만 이런 안이한 방법은 심각한 문제를 발생시킬수 있는데, 기존 클래스에 코드를 계속 추가하다 보면, 결국은 대규모 메소드를 갖는 거대한 클래스가 되버린다.  
이후 신규 기능 추가는 물론이고 기존 기능을 이해하는데에도 많은 시간이 들게 된다.  
클래스가 커지면 어떠한 문제가 있는가? 첫번째론 너무나 많은 메소드나 인스턴스 변수 등으로 인해 어디에 어떤 영향이 미치는지 파악하기 혼란스러워 진다.  
두번째로는 작업계획의 조정이다. 한개의 클래스가 10개 20개의 책임을 가지고 있으면 그 클래스를 변경해야 하는 이유도 매우 많아지고 작업 주기 동안 다수의 프로그래머들이 해당 클래스에 서로 다른 이유로 동시에 변경을 시도하게 되고, 그 작업들이 동시에 수행되면 심각하게 혼란해진다.  
그리고 세번째로 크기가 거대한 클래스는 테스트 작성이 어렵다는 문제가 더해지면 더욱 심각해지게 된다.  
거대한 클래스를 개선하는 핵심은 *리펙토링* 이다. 리팩토링은 클래스를 작은 클래스들로 쪼개는데 도움을 준다.  
문제는 어떤 작은 클래스로 되는지 파악하는 것이다. 이 장에서는 참고할 만한 몇가지 지침을 알아보자.  

> *단일책임원칙* -> 모든 클래스는 단일한 책임을 가져야한다. 클래스는 시스템 내에서 한개의 목적만을 가져야하고, 클래스를 변경하는 이유도 한개여야 한다.

단일책임원칙을 매우 단순하게 생각하면 "모든 클래스가 오직 한개의 메소드만 가져야 한다." 라고 말하기 쉽다.  
확실히 메소드가 곧 책임이라고 생각 할수도 있지만 책임의 실제 의미는 클래스의 '주요 목적'을 논의할때 명확히 드러난다.
![KakaoTalk_20230313_144126310](https://user-images.githubusercontent.com/50142323/224618442-9d0dd5e7-81e2-4715-9ee3-81c6b3eeaec2.jpg)
이 그림을 보면 이 클래스는 어떤 언어의 규칙 표현식을 포함하는 문자열을 평가한다. 이 클래스는 어떤 책임들을 가지고 있을까?  
RuleParser 클래스 이므로 파싱 책임을 가질것이다. 그런데 파싱이 이 클래스의 주요 목적일까? 파싱뿐 아니라 평가도 하기 때문에 파싱이 주요목적이라고 말할 수 없는 것 같다.  
그 밖으론 이 클래스는 current 변수에 현재 파싱중인 문자열을 저장한다. 파싱중인 문자열의 현재 위치를 저장하는 currentPosition 변수도 갖고 있는데 이 두개의 책임은 파싱에 포함시켜도 좋을것 같다.  
또 다른 변수인 variables를 살펴보면 이 변수는 a+3와 같은 산술식을 계산하기 위해 파싱중에 사용되는 변수와 그 값의 쌍을 저장한다.  
addVariable 메소드를 호출할 경우, a+3 식을 평가하면 그 결과는 4가 된다. 따라서 이 클래스는 '변수 관리' 라는 책임도 갖고 있는것 같다.
이것들 말고도 책임이 있을까? 책임을 찾는 또다른 방법은 메소드 이름을 살펴보는 것이다.  
이름에 동일 단어가 포함된 메소드끼리 묶으면 다음과 같이 분류할 수 있다.
![KakaoTalk_20230313_150308714](https://user-images.githubusercontent.com/50142323/224620236-67302c35-7ecc-4ce9-88fd-afd9cbb59c11.jpg)
evaluate 메소드는 이 클래스의 진입지점(endpoint) 이며 클래스의 주요 책임인 '평가'를 수행한다. 이름이 Expression으로 끝나는 네게의 메소드들은 Node 객체를 매개변수를 입력받고 하위식의 값을 나타내는 정수형 값을 반환하는 점이 동일하다.  
Term 의 이름을 갖는 메소드들은 토큰화와 관련있는 것처럼 보인다. 그리고 addVariable 메소드는 변수 관리와 관련 있다.  
지금까지의 내용을 정리하면 다음과 같은 책임들을 가진다
 - 파싱
 - 표현식 평가
 - 토큰화
 - 변수 관리

이런 책임들을 모두 별도로 나눠서 클래스를 설계했다면 다음과 같은 구조가 됐을 것이다.  
![KakaoTalk_20230313_151459898](https://user-images.githubusercontent.com/50142323/224621944-460694f7-94a3-4c37-8b62-3b199f02a7bb.jpg)
이 설계는 지나치게 세분화 된것 일수도 있고, 상당부분이 가설에 기초하고 있다.  
실제로 거대한 클래스를 다룰때 중요한 것은, 서로 다른 책임들을 식별한 후 적절한 위치로 옮기는 방법을 찾는 것이다.

## 책임파악
좀전의 예제는 클래스를 작은 클래스로 나누는 방법을 보여줬다.  
먼저 모든 메소드들을 나열한 후 그 이름을 통해 메소드의 목적이 무엇인지 유추한 후 비슷한 이유를 갖는 메소드들을 그룹화 했다.  
이런 책임파악 기법을 *메소드 그룹화* 라고 부른다.  
책임을 찾을수 있는 능력은 중요한 설계 스킬로서 충분한 연습이 요구된다. 중요한 점은 책임 파악 및 그 책임의 적절한 분리 방법을 배워야 한다는 것이다.  
다음은 기존 코드의 책임을 찾아내는데 사용할 수 있는 경험칙들을 설명한다.

> *경험칙 #1 : 메소드들을 분류한다.*
> 이름이 비슷한 메소드들을 찾는다. 클래스의 모든 메소드들을 접근속성(public, private 등)과 함께 적어보고, 묶을 만한 메소드들이 있는지 찾아보자.


## 그밖의 기법들

## 더 나아가기
### 전략
### 전술

## 클래스 추출을 마친 후

# 25. 의존 관계 제거 기법 
이번 장에서는 의존 관계 제거 기법들을 소개한다.  

## 매개변수 적응
메소드를 변경하려고 할 때 메소드의 매개변수로 인한 의존 관계는 골칫거리가 되곤 한다.
매개변수의 클래스에 인터페이스 추출을 사용할 수 없거나 매개변수를 가짜로 만들기 어려울 때는 매개변수 적응 기법을 사용하자.  

### 단계
매개변수 적응을 수행하는 순서는 다음과 같다.  
1. 메소드에서 사용할 새로운 인터페이스를 생성하자. 그 메소드는 가능한 단순하고 소통할 수 있게 만들되, 메소드 안에서 복잡한 변경을 만들지 못하도록 하라.
2. 새로운 인터페이스를 위한 가짜 구현체를 하나 생성하자.
3. 그 인터페이스를 위한 가짜 구현체를 하나 생성하자.
4. 그 가짜 구현체를 메소드에 전달하는 단순한 테스트 케이스를 작성하자.
5. 새로운 매개변수를 사용하기 위해 메소드 안에 필요한 변경을 가하자.
6. 가짜 구현체를 이용해 메소드를 테스트할 수 있는지 검증하기 위해 테스트 루틴을 실행해보자.

## 메소드 객체 추출
대부분의 애플리케이션에서 대규모 메소드는 작업하기 힘들다.  
대규모 메소드를 포함하는 클래스를 인스턴스화 해서 테스트 하네스 안에 넣을수 있으면 테스트 루틴 작성을 시작할 수 있다.  
하지만 어떤 경우에는 클래스를 단독으로 인스턴스화 하는데 많은 시간이 걸릴 수 있다.  
변경 대상 메소드의 크기가 작고 인스턴스 변수를 사용하지 않는 경우라면, 정적 메소드 드러내기 기법을 사용하고, 메소드 크기가 크거나 인스턴스 변수 및 메소드를 사용하는 경우라면 메소드 객체 추출 기법을 이용해보자.  
이 리팩토링 기법의 개념을 한마디로 말하면 대규모 메소드를 새로운 클래스로 바꾸는 것이다.  
이 새로운 클래스로부터 생성된 객체는 단일 메소드 였던 코드를 구현한 것이기 때문에 메소드 객체라고 부른다.  
대체로 이 기법을 사용함으로서 의존관계를 제거하기 쉽게 되고 코드를 더 나은 상태로 바꾸기가 쉬워진다.  
매소드 객체 추출 기법은 몇가지 변형이 있는데, 가장 단순한 것은 기존 메소드가 인스턴스 변수나 메소드를 전혀 사용하지 않는 경우이다. 이때는 기존 클래스에 대한 참조를 전달할 필요가 없다.  
대상 메소드가 기존 클래스의 인스턴스 변수만을 사용하는 경우도 있다. 이 경우는 해당 데이터를 갖고 있는 클래스를 새로 만들고 메소드 객체에 인수로 전달하면 된다.

### 단계
테스트 루틴이 없는 상황에서 안전하게 메소드 객체 추출기법을 사용하려면 다음의 과정을 거쳐야 한다.
1. 메소드 코드를 이동시킬 클래스를 작성한다.
2. 이 클래스의 생성자를 정의하고 서명 유지 기법을 수행해 메소드의 매개변수 목록을 그대로 복사한다. 메소드가 기존 클래스의 인스턴스 변수나 메소드를 사용한다면, 기존 클래스에 대한 참조를 생성자의 첫번째 매개변수로서 추가한다.
3. 생성자의 모든 매개변수에 대해 매개변수와 동일한 타입의 인스턴스 변수를 선언한다. 메소드의 매개변수 목록을 형식에 맞게 그대로 복사해 인스턴스 변수를 선언함으로서 서명 유지를 할수 있다. 생성자에서는 모든 인수를 인스턴스 변수에 대입한다.
4. 신규 클래스 내에 비어있는 실행 메소드를 작성한다. 이 메소드에는 run()이라는 이름이 가장 흔히 쓰인다.
5. 기존 메소드의 본문을 실행 메소드르 옮기고 컴파일해 컴파일러에게 맡기기 기법을 수행한다.
6. 컴파일러에서 발생하는 오류 메시지는 실행 메소드가 어느 부분에서 기존 클래스의 메소드나 변수를 사용하는지 알려준다. 오류메시지를 바탕으로 메소드를 수정해 컴파일이 이뤄지도록 한다.
7. 새로운 클래스가 컴파일되고 나면, 기존 메소드에서 새로운 클래스의 인스턴스를 생성하고 처리 작업을 새로운 클래스에 위임한다.
8. 필요하다면 인터페이스 추출 기법을 사용해 기존 클래스와의 의존관계를 제거한다.

## 정의 완성
일부 언어에서는 어떤 타입을 선언한 후 다른 곳에서 이를 정의할 수 있다. 이 기능이 특히 사용되는 언어는 C와 C++이다.  
둘다 함수나 메소드를 어떤 위치에서 선언한 후 다른위치에서 정의할 수 있다. 이 기능을 활용해 의존 관계를 제거할 수 있다.

### 단계
C++에서 정의 완성 기법을 사용하려면 다음의 단계를 따른다.
1. 대체하려는 정의를 갖는 클래스를 식별한다.
2. 메소드 정의가 헤더 파일이 아닌 소스 파일에 있음을 확인한다.
3. 대상 클래스의 테스트용 소스 파일에 있는 헤더 파일을 인클루드 한다.
4. 이 클래스의 소스 파일이 빌드에 포함돼 있지 않음을 확인한다.
5. 빌드를 수행해서 누락된 메소드를 발견한다.
6. 빌드가 정상적으로 완료될때까지 테스트용 소스 파일에 누락된 메소드를 계속 추가한다.

## 전역 참조 캡슐화
전역 요소에 대한 의존 관계에 문제가 있는 코드를 테스트할 때는 기본적으로 세개의 선택지가 있다.  
1. 테스트할 때 전역 요소가 다르게 동작하도록 하는것.
2. 다른 전역 요소와 연결시키는 것.
3. 전역요소를 캡슐화해 다른 것들과 분리하는 것.

이 중 마지막 방법을 전역 참조 캡슐화라고 부른다.  

### 단계
전역 참조 캡슐화를 사용하려면 다음에 소개하는 단계들을 밟는다.
1. 캡슐화하고자 하는 전역 요소를 식별한다.
2. 이 요소들을 캡슐화하기 위한 클래스를 작성한다.
3. 전역 요소들을 이 클래스로 복사한다. 변수가 포함된 경우, 클래스 안에서 초기화한다.
4. 기존의 전역 요소 선언을 주석 처리한다.
5. 새로운 클래스의 전역 인스턴스를 선언한다.
6. 기존 전역 요소에 대한 미해결 참조들을 컴파일러에게 맡기기 기법을 통해 찾는다.
7. 미해결 참조의 앞에 신규 클래스의 전역 인스턴스 이름을 추가한다.
8. 가짜 클래스를 사용하려는 위치에 정적 set 메소드 도입, 생성자 매개변수화, 메소드 매게변수화, 전역 참조를 get 메소드로 대체 등의 기법을 사용한다.

## 정적 메소드 드러내기
인스턴스 변수나 메소드를 사용하지 않는 메소드일 경우, 정적 메소드로 바꾼다. 정적 메소드가 되면 클래스를 인스턴스화하지 않고도 테스트 루틴 내에 둘 수 있다.

### 단계
정적 메소드 드러내기를 사용하려면 다음에 소개하는 단계들을 밟는다.  
1. 정적 메소드로 드로내고자 하는 메소드에 접근하는 테스트 루틴을 작성한다.
2. 메소드 본문을 정적 메소드로서 추출한다. 이때 서명 유지를 잊지 말고 수행한다. 추출된 메소드에는 다른 이름을 사용해야 할 수 있다.
3. 컴파일한다.
4. 인스턴스 변수나 메소드에 접근할 때 오류가 발생한다면, 정적 변수나 메소드로 선언해도 되는지 확인한다. 가능하다면, 정적으로 바꿔서 컴파일을 통과한다.

## 호출 추출과 재정의
테스트를 방해하는 의존관계가 매우 지역적인 경우가 있다. 이럴 때는 단일한 메소드 호출만 대체하면 되는데, 이 메소드 호출의 의존관계를 제거할 수 있다면 테스트할 때의 이상한 부작용을 막고 호출할 때 전달되는 값을 감지할 수 있다.  

### 단계
호출 추출과 재정의 기법을 수행하는 순서는 다음과 같다.
1. 추출하고자 하는 호출을 식별하고, 메소드 선언을 찾는다. 서명 유지 기법을 사용 할 수 있도록 이 메소드의 서명을 복사한다.
2. 현재 클래스에 신규 메소드를 작성한다. 단계 1에서 복사했던 서명을 이 메소드에 부여한다.
3. 기존의 메소드 호출 부분을 신규 메소드 호출로 대체한다.
4. 테스트용 서브클래스를 도입하고 신규 메소드를 재정의 한다.

## 팩토리 메소드 추출과 재정의
클래스를 위한 테스트 루틴을 작성할 때, 생성자 안에서 객체를 생성하다가 열받는 경우가 생기는데, 객체를 생성할 때 테스트 하네스 안에서는 실행 불가능한 처리가 포함될 수 있기 때문이다.  
또 어떤 경우에는 감지용 객체를 넣고 싶지만 객체 생성이 생성자에 직접 작성되어 있으므로 불가능할 때도 있다.  
> 초기화 처리를 생성자 안에 직접 작성하면 테스트 루틴에서 이를 회피하기가 매우 어려울 수 있다.

### 단계
팩토리 메소드 추출과 재정의를 사용하려면 다음과 같은 단계를 거친다.  
1. 생성자 안에서의 객체 생성을 식별한다.
2. 생성과 관련된 모든 처리를 팩토리 메소드로서 추출한다.
3. 테스트용 서브클래스를 작성하고, 그 안에서 팩토리 메소드를 재정의 함으로서 테스트 루틴에서 문제를 일으키는 객체 생성과 관계된 의존관계를 해결한다.

## get 메소드 추출과 재정의
이 리팩토링 기법의 핵심은 가짜 객체로 대체하려는 인스턴스 변수를 위한 get 메소드를 도입하는 것이다.  
그리고 클래스 내에서 이 변수를 사용하는 모든 곳에서 get 메소드를 사용하도록 코드를 변경한다.  
이후 서브 클래스를 작성해 get 메소드를 재정의 함으로서 테스트할 때 대체 객체를 제공할 수 있다.  
이 기법의 단점 중 하나는 초기화 되기 전에 해당 변수를 사용할 위험성이 있다는 점이다.  

### 단계
이 기법을 사용하려면 다음 단계를 거친다.  
1. get 메소드를 필요로 하는 객체를 식별한다.
2. 객체 생성에 필요한 로직을 모두 추출해서 get 메소드에 넣는다.
3. 객체를 사용하는 부분을 모두 get 메소드 호출로 대체한다. 그리고 모든 생성자에서 이 객체에 대한 참조를 널값으로 초기화 한다.
4. get 메소드에 첫 호출 시의 로직을 추가하고, 객체 참조가 널일 때 객체를 생성해서 참조에 할당되도록 한다.
5. 서브클래스를 작성하고 get 메소드를 재정의해 테스트 루틴에서 사용되기 위한 대체 객체를 제공한다.

## 구현체 추출
인터페이스 추출은 손쉬운 기법이지만, 이름을 짓기가 어렵다. 추출하려는 인터페이스의 이름이 이미 클래스 이름으로서 사용되는 경우가 자주 있다.  
클래스 이름 변경이나 인터페이스 추출 기능을 지원하는 IDE가 있으면 별문제 없지만, 그렇지 않다면 몇개의 선택지가 있다.
 - 바보 같은 이름을 짓는다.
 - 추출하려는 메소드들을 조사하고, 이 메소드들이 클래스에서 특정 의미를 갖는 public 메소드의 집합인지 확인한다. 만약 그렇다면, 이는 새로운 인터페이스에 대한 별도의 이름을 시사할 가능성이 있다.
이름 짓기는 설계의 핵심 중 하나다. 좋은 이름을 선택하면 시스템을 이해하고 작업하기가 쉽다.  
어떤 클래스의 이름이 인터페이스 이름으로서 사용하기에 딱 맞는데 리팩토링 자동화 도구가 없을 경우, 코드를 분리하기 위해 구현체 추출 기법을 사용한다.  
클래스의 구현 부분을 추출하기 위해 서브클래스를 작성하고 실체 메소드를 모두 서브클래스로 밀어내림으로서 클래스를 인터페이스로 바꾸는 것이다.  

### 단계
1. 기존 클래스의 선언을 복사해서 다른 이름을 붙인다. 추출된 클래스에 대한 명명 규칙이 있다면 편리할 것이다.
2. 기존 클래스에서 public이 아닌 메소드와 모든 변수를 삭제해 인터페이스로 바꾼다.
3. 남아있는 public 메소드를 추상 메소드로 만든다. C++의 경우 추상 메소드로 만든 메소드가 가상 메소드가 아니며 재정의되지 않았음을 확인한다.
4. 인터페이스의 소스 파일에 포함된 import문이나 include문이 반드시 필요한지 확인한다. 그중의 상당수를 제거해도 될때가 많다. 이를 확인하기 위해 컴파일러에게 맡기기 기법을 사용할 수도 있다.
5. 배포용 클래스가 새로운 인터페이스를 구현하도록 만든다.
6. 배포용 클래스를 컴파일해 인터페이스에 정의된 메소드가 모두 구현됐는지 확인한다.
7. 시스템의 나머지 부분을 컴파일해서 기존 클래스의 인터페이스를 생성하는 곳을 전부 찾는다. 발견된 곳들을 배포용 신규 클래스의 생성으로 대체한다.
8. 다시 컴파일 하고 테스트한다.

## 인터페이스 추출
많은 언어에서 인터페이스 추출은 가장 안전한 의존관계 제거 기법중 하나다. 혹시 순서를 잘못 따라도 컴파일러가 즉시 알려주기 떄문에 버그가 생길 가능성이 매우 낮다.  
이 기법의 핵심은 어떤 클래스에 대해 특정 상황에서 사용하려는 메소드들의 선언을 포함하는 인터페이스를 작성하는 것이다.  
테스트하려는 클래스에 대해 인터페이스를 구현한 가짜 객체를 전달함으로서 감지와 분리를 수행할수 있다.  
인터페이스 추출은 세가지 방법이 있으며, 주의해야 할 함정도 있다.
첫번째로는 리팩토링 자동화 도구의 지원을 받는것이고 두번째로는 이번 절에서 설명하는 단계를 밞아서 단계적으로 인터페이스를 추출해나가는 것이다.  
세번째로는 클래스로부터 몇개의 메소드를 묶어서 자르기/복사하기 및 붙여넣기를 수행해 인터페이스에 선언하는 것이다.

### 단계
인터페이스 추출의 두번째 방법을 사용하려면 다음의 단계를 밟는다.
1. 적절한 이름의 인터페이스를 새로 작성한다. 아직은 어떤 메소드로 추가하지 않는다.
2. 추출 대상 클래스에서 이 인터페이스를 구현하도록 한다. 인터페이스가 아직 메소드를 갖고 있지 않으므로 동작에 문제를 일으킬 일은 없다. 그래도 검증을 위해 컴파일하고 테스트 루틴을 실행해 보는 것이 좋다.
3. 해당 객체를 사용하는 위치를 변경해서 기존 클래스 대신에 인터페이스를 사용하도록 한다.
4. 시스템을 컴파일한다. 컴파일러가 오류를 보고하고 메소드 호출에 대해 신규 메소드 선언을 인터페이스에 추가한다.

## 인스턴스 위임
정적 메소드는 여러가지 이유에서 사용된다. 가장 흔한 이유중 하나로는 싱글톤 디자인 패턴을 구현하는 것을 꼽을 수 있으며, 유틸리티 클래스 작성도 정적 메소드를 사용하는 이유 중 하나다.  
유틸리티 클래스는 많은 설계에서 폭넓게 사용되는데, 인스턴스 변수나 인스턴스 메소드를 갖지 않는 대신에 정적 메소드와 상수로 구성된 클래스를 가리킨다.  
사람들은 여러 이유로 유틸리티 클래스를 작성하는데, 대부분의 경우 유틸리티 클래스는 특정 메소드 집합의 공통적인 추상 개념을 찾기 힘들 때 주로 작성된다.  
대부분의 경우에는 클래스가 인스턴스 데이터와 메소드를 갖게 함으로서 필요한 처리를 수행하게 할 수 있다.  
정적 메소드가 있다고 해도 테스트 환경에서 어떤 까다로운 것에 의존하지 않는 한 문제의 원인이 되지는 않는다.  
하지만 골치 아픈 것에 의존하고 있을 경우에는 객체 봉합 기법을 사용해서 정적 메소드의 동작을 어떤 다른 것으로 대체하고 싶을 수 있다. 이럴떄는 어떻게 할까?  
한가지 가능한 방법은 클래스에 위임용 인스턴스 메소드를 도입하는 것이다. 이 경우 정적 메소드 호출을 객체에 대한 메소드 호출로 대체할 방법을 찾아내야 한다.

### 단계
1. 테스트 환경에서 사용하면 문제를 일으킬 정적 메소드를 식별한다.
2. 단계 1에서 식별된 메소드에 대한 인스턴스 메소드를 클래스 내에 작성한다. 이때 서명 유지 기법을 잊지 말고 수행한다. 이 인스턴스 메소드느느 정적 메소드에 처리를 위임한다.
3. 테스트 루틴으로 보호하려는 클래스 내에서 정적 메소드를 호출하는 위치를 찾는다. 정적 메소드를 호출하려는 위치에 인스턴스를 전달하기 위해 메소드 매개변수화 기법이나 그 밖의 의존 관계 제거 기법을 사용한다.
4. 문제가 있었던 기존의 정적 메소드 호출을 인스턴스 메소드 호출로 대체한다.

 


# 03. 감지와 분리
이상적인 환경이라면 변경 작업을 하기 전 특별히 할 일이 없다.  
테스트를 하고 싶은 대상을 테스트 코드 내에서 객체를 생성해 곧바로 작업을 하면 된다.  
하지만 불행하게도 클래스들의 의존 관계들 때문에 이것은 거의 불가능하다.  
의존관계를 제거해야 하는 이유는 무엇일까? 크게 두가지로 볼수 있다.
1. 감지 : 코드 내에서 계산된 값에 접근하여 변경이나 값을 확인할 수 없을 때
2. 분리 : 코드를 테스트 코드 내에서 실행할 수 없을 때 코드 분리를 위해

다음의 예제를 보자 네트워크 관리 애플리케이션에 NetworkBridge라는 클래스가 있다.
```Java
public class NetworkBridge {
    public NetworkBridge(EndPoint[] endpoints){
        ...
    }

    public void formRouting(String sourceId, String destId){
        ...
    }
...
}
```
위 코드에 대한 간략한 설명은
1. NetworkBridge 클래스는 EndPoint 배열을 입력받고, 하드웨어에 전달하여 트래픽을 관리한다.
2. 사용자는 해당 클래스의 메소드를 사용하여 종점 간 트래픽 경로를 제어할 수 있다.
3. NetworkBridge는 이러한 작업들을 진행하기 위해 전달받은 EndPoint 설정을 변경하고 Endpoint 클래스의 인스턴스들은 소켓을 열고 네트워크를 통해 특정 장치와 통신할수 있다.

테스트 관점에서 몇가지 문제점들이 눈에 보이는데,
1. 이 클래스의 객체는 실제 하드웨어를 자주 호출할텐데, 테스트를 하기 위해 실제 하드웨어가 필요한가?
2. NetworkBridge 내부에서 통신을 위해 EndPoint 객체에 무슨 작업을 했을까? → 블랙박스이기에 내부 작업을 들여다 볼수 없다.

이것이 문제가 되지 않을수도 있다.  
네트워크상의 패킷을 읽을수 있는 코드를 작성할 수 있고, 실제 하드웨어를 구입할수도 있다.  
또는 배선작업을 통해 네트워크 종점들의 로컬 클러스터를 구성해 테스트에 사용할 수도 있다.  
문제는 이러한 방법들이 해결책이 될수는 있지만, 엄청난 노력과 비용이 발생하게 된다는 것이다.  

이 예제는 감지와 분리 문제를 모두 보여주는데, 클래스의 메소드가 호출될 때의 영향을 감지할 수도 없고, 애플리케이션의 나머지 부분과 분리해서 실행할 수도 없기 때문이다.  
감지와 분리 중 어느쪽이 더 어려운 문제인지에 대한 명확한 답은 없다.  
다만 분명한 것은 분리에 사용되는 기법은 매우 다양하고, 감지의 경우에는 거의 언제나 다음 기법을 사용한다.

## 협업 클래스 위장하기
레거시 코드를 다룰 때의 가장 큰 문제 중 하나가 의존관계이다.  
특정 코드만 독립적으로 실행해 어떻게 동작하는지 테스트하려면, 대체로 다른 코드에 대한 의존관계를 제거할 필요가 있지만, 이것은 간단한 일이 아니다.  
보통 그 다른 코드가 우리가 수행하는 작업의 영향을 감지할수 있는 유일한 위치일때가 많기 때문이다.  
따라서 그 다른 코드를 별도의 코드로 대체할수 있다면, 변경 대상을 테스트하는 루틴을 작성할수 있을 것이고, 객체 지향 프로그래밍에서는 이 별도의 코드를 가리켜서 가짜객체 혹은 위장객체(fake object) 라고 부른다.

### 가짜 객체
가짜 객체란 어떤 클래스를 테스트할 때 그 클래스의 협업 클래스를 모방하는 객체를 말한다.
다음은 POS시스템에 Sale이란 클래스가 있고, 이 클래스의 scan()메소드는 고객이 구매중인 품목의 바코드를 읽어 해당품목의 이름과 가격을 디스플레이 화면에 출력하는 예제이다.  

